## Connection-oriented and Connectionless Protocols

So far, we've mostly focused on TCP, which is a connection-oriented protocol. A connection-oriented protocol is one that establishes a connection, and uses this to ensure that all data has been properly transmitted. A connection at the transport layer implies that every segment of data sent is acknowledged. This way, both ends of the connection always know which bits of data have definitely been delivered to the other side and which haven't. Connection-oriented protocols are important because the Internet is a vast and busy place. And lots of things could go wrong while trying to get data from point A to point B. You might remember from our lesson about the physical layer that even some minor crosstalk from a neighboring twisted pair in the same cable can be enough to make a cyclical redundancy check fail. This could cause the entire frame to be discarded, yikes. If even a single bit doesn't get transmitted properly, the resulting data is often incomprehensible by the receiving end. And remember that at the lowest level, a bit is just an electrical signal within a certain voltage range. But there are plenty of other reasons why traffic might not reach its destination beyond line errors. It could be anything. Pure congestion might cause a router to drop your traffic in favor of forwarding more important traffic. Or a construction company could cut a fiber cable connecting two ISPs, anything's possible. Connection-oriented protocols, like TCP, protect against this by forming connections and through the constant stream of acknowledgments. Our protocols at lower levels of our network model, like IP and Ethernet, do use checksums to ensure that all the data they received was correct. But did you notice that we never discussed any attempts at resending data that doesn't pass this check? That's because that's entirely up to the transport layer protocol. At the IP or Ethernet level, if a checksum doesn't compute, all of that data is just discarded. It's up to TCP to determine when to resend this data. Since TCP expects an ack for every bit of data it sends, it's in the best position to know what data successfully got delivered and can make the decision to resend a segment if needed. This is another reason why sequence numbers are so important. While TCP will generally send all segments in sequential order, they may not always arrive in that order. If some of the segments had to be resent due to errors at lower layers, it doesn't matter if they arrive slightly out of order. This is because sequence numbers allow for all of the data to be put back together in the right order. It's pretty handy. Now, as you might have picked up on, there's a lot of overhead with connection-oriented protocols like TCP. You have to establish the connection. You have to send a stream of constant streams of acknowledgements. You have to tear the connection down at the end. That all accounts for a lot of extra traffic. While this is important traffic, it's really only useful if you absolutely, positively have to be sure your data reaches its destination. You can contrast this with connectionless protocols. The most common of these is known as UDP, or User Datagram Protocol. Unlike TCP, UDP doesn't rely on connections, and it doesn't even support the concept of an acknowledgement. With UDP, you just set a destination port and send the packet. This is useful for messages that aren't super important. A great example of UDP is streaming video. Let's imagine that each UDP datagram is a single frame of a video. For the best viewing experience, you might hope that every single frame makes it to the viewer, but it doesn't really matter if a few get lost along the way. A video will still be pretty watchable unless it's missing a lot of its frames. By getting rid of all the overhead of TCP, you might actually be able to send higher quality video with UDP. That's because you'll be saving more of the available bandwidth for actual data transfer, instead of the overhead of establishing connections and acknowledging delivered data segments.





到目前为止，我们主要关注 TCP，这是一种面向连接的协议。 面向连接的协议是建立连接的协议，并 使用它来确保所有数据都已正确传输。 传输层的连接意味着 确认发送的每个数据段。 通过 这种方式，连接的两端总是知道哪些位数据 已经传送到另一端，哪些没有。 面向连接的协议非常重要，因为互联网是一个庞大 而繁忙的地方。 在 尝试从 A 点到 点 B 的数据时，很多事情可能会出错。 您可能记得，从我们关于物理层的课程中，即使在 同一电缆中相邻双绞线的一些小串扰也足以使 周期性冗余检查失败。 这可能会导致整个帧被丢弃，ykes。 如果即使是一个位没有得到正确传输，则 接收端通常无法理解生成的数据。 请记住，在最低水平， 一点只是一个电压范围内的电信号。但是， 除了线路错误之外，流量可能无法到达目的地，还有很多其他原因。 它可能是任何东西。 纯粹拥塞可能会导致路由器丢弃您的流量，而转发 更重要的流量。 或者建筑公司可以切断连接两个 ISP 的光纤电缆， 任何事情都是可能的。 面向连接的协议（如 TCP）通过形成 连接和通过不断的确认流来防止这种情况。 我们的网络模型较低级别的协议（例如 IP 和以太网）确实 使用校验和来确保他们收到的所有数据都正确无误。 但是，您是否注意到我们从未讨论过重新发送 未通过此检查的数据的任何尝试？ 这是因为这完全取决于传输层协议。在 IP 或以太网级别，如果校验和不计算，则 只会丢弃所有这些数据。 由 TCP 决定何时重新发送此数据。 由于 TCP 希望它发送的每一 位数据都能确认，因 此它最好能够了解哪些数据已成功传送，并且可以根据需要决定重新发送数据段。 这是序列号如此重要的另一个原因。 虽然 TCP 通常会按顺序发送所有段，但 它们可能并不总是按照该顺序到达。 如果由于较低层的错误而不得不重新发 送某些段，那么它们是否略有偏差并不重要。 这是因为序列号允许 以正确的顺序将所有数据放回一起。 这是相当方便的。 现在，正如你可能已经认识到的 那样，像 TCP 这样的面向连接的协议有很多开销。 您必须建立连接。 你必须发送一个常量的确认流。 你必须在最后撕下连接。 这一切都占了很多额外的流量。 虽然这是重要的流量，但只有 当您绝对需要确保您的数据到达目的地时，它才有用。 您可以将其与无连接协议进行对比。 其 中最常见的是 UDP 或用户数据报协议。 与 TCP 不同，UDP 不依赖于连接 ，甚至不支持确认的概念。 使用 UDP，您只需设置一个目标端口并发送数据包。 这对于不是超级重要的消息非常有用。 UDP 的一个很好的例子是流式传输视频。 让我们想象一下，每个 UDP 数据报都是视频的单帧。 为了获得最佳的观看体验，您可能希望每个帧都能让观 众看到，但是如果一些帧在路上迷路并不重要。 视频仍然是非常可观看的，除非它缺少了很多帧。 通过摆脱 TCP 的所有开销， 您实际上可以使用 UDP 发送更高质量的视频。 这是因为您将节省更多的可用带宽用于 实际数据传输，而不是建立连接和 确认传送数据段的开销。