## DNS and UDP

DNS is a great example of an application layer service that uses UDP for the transport layer instead of TCP. This can be broken down into a few simple reasons. Remember that the biggest difference between TCP and UDP is that UDP is connectionless. This means there is no setup or teardown of a connection. So much less traffic needs to be transmitted overall. A single DNS request and its response can usually fit inside of a single UDP datagram, making it an ideal candidate for a connectionless protocol. It's also worth calling out that DNS can generate a lot of traffic. It's true that caches of DNS entries are stored both on local machines and caching name servers, but it's also true that if the full resolution needs to be processed, we're talking about a lot more traffic. Let's see what it would look like for a full DNS lookup to take place via TCP. First, the host that's making the DNS resolution request would send a SYN packet to the local name server on port 53, which is the port that DNS listens on. This name server would then need to respond with a SYN ACK packet, that means the original host would have to respond with an ACK in order to complete the three-way-handshake. That's three packets. Now, that the connection has been established, the original host would have to send the actual request. I'd like the IP address for food accomplice. When it receives this request, the name server would have to respond with another ACK. I got your request for food.com. We're up to five packets sent now. In our scenario, the first caching name server doesn't have anything cached for food.com. So, it needs to talk to a root name server to find out who's responsible for the.comTLD. This would require a three-way-handshake. The actual request, the ACK of the request, the response, and then the ACK of the response. Finally, the connection would have to be closed via a four-way-handshake. That's 11 more packets or 16 total. Now that the recursive name server has the correct TLD name server, it needs to repeat that entire process to discover the proper authoritative name server. That's 11 more packets, bringing us up to 27 so far. Finally, the recursive name server would have to repeat the entire process one more time while talking to the authoritative name server in order to actually get the IP of food.com. This is 11 more packets for a running total of 38. Now that the local name server finally has the IP address of food.com, it can finally respond to the initial request. A response to the DNS resolver that originally made the request, and then this computer sends an ACK back to confirm that it received the response. That's two more packets, putting us at 40. Finally, the TCP connection needs to be closed via a four-way-handshake. This brings us to a grand total of 44 packets at the minimum in order for a fully recursive DNS request to be fulfilled via TCP. 44 packets isn't really a huge number in terms of how fast modern networks operate. But it adds up fast as you can see. Remember that DNS traffic is just a precursor to actual traffic. A computer almost always performs a DNS lookup because it needs to know the IP of the domain name in order to send additional data, not just because it's curious. Now, let's check out how this would look with UDP. Spoiler alert, it doesn't take as many packets. The original computer sends a UDP packet to its local name server on port 53 asking for the IP for food.com, that's one packet. The local name server acts as a recursive server and sends up a UDP packet to the root server which sends a response containing the proper TLD name server, that's three packets. The recursive name server sends a packet to the TLD server and receives back a response containing the correct authoritative server. We're now at five packets. Next, the recursive name server sends its final request to the authoritative name server which sends a response containing the IP for food.com. That's seven packets. Finally, the local name server responds to the DNS resolver that made the request in the first place with the IP for food.com. That brings us to a grand total of eight packets. See, way less packets. You can see now how much overhead TCP really requires. And for something as simple as DNS, it's just not needed. It's the perfect example for why protocols like UDP exist in addition to the more robust TCP. You might be wondering how error recovery plays into this, since UDP doesn't have any. The answer is pretty simple. The DNS resolver just asks again if it doesn't get a response. Basically, the same functionality that TCP provides at the transport layer is provided by DNS at the application layer in the most simple manner. A DNS server never needs to care about doing anything but responding to incoming lookups, and a DNS resolver simply needs to perform lookups and repeat them if they don't succeed. A real showcase of the simplicity of both DNS and UDP. I should call out that DNS over TCP does in fact exist and is also in use all over. As the Web has gotten more complex, it's no longer the case that all DNS lookup responses can fit in a single UDP datagram. In these situations, a DNS name server would respond with a packet explaining that the response is too large. The DNS client would then establish a TCP connection in order to perform the lookup.



DNS 是将 UDP 用于传输层而不是 TCP 的应用程序层服务的一个很好的示例。 这可以分解为几个简单的原因。 请记住，TCP 和 UDP 之间的最大区别在于 UDP 是无连接的。 这意味着没有设置或拆除连接。 因此，需要整体传输的流量要少得多。 单个 DNS 请求及其响应通常可以放在单个 UDP 数据报中， 使其成为无连接协议的理想选择。 同样值得一提的是，DNS 可以产生大量流量。 确实，DNS 条目的缓存存储在 本地计算机和缓存名称服务器上， 但如果需要处理完整的分辨率， 我们正在谈论更多的流量。 让我们来看看通过 TCP 进行的完整 DNS 查找会是什么样子。 首先，发出 DNS 解析请求的主机将向端口 53 上的本地名称服务器发送一个 SYN 数据包， 该端口是 DNS 侦听的端口。 然后，此名称服务器需要使用 SYN ACK 数据包进行响应，这意味着原始主机必须使用 ACK 响应才能完成三向握手。 这是三个数据包 现在，连接已经建立， 原始主机必须发送实际请求。 我想要食物共犯的 IP 地址 当它收到此请求时， 名称服务器必须使用另一个 ACK 进行响应。 我收到了你的食品网的要求 我们现在最多发送了五个数据包 在我们的场景中，第一个缓存名称服务器没有任何缓存的 food.com。 因此，它需要与根名称服务器交谈，以找出谁负责 .comtld。 这将需要三向握手。 实际请求、请求的 ACK、 响应，然后是响应的 ACK。 最后，必须通过四向握手关闭连接。 还 有 11 个数据包或者总共 16 个 现在递归名称服务器具有正确的 TLD 名称服务器， 它需要重复整个过程才能发现正确的权威名称服务器。 还 有 11 个数据包，到目前 为止，我们已经达到 27 个。 最后，递归名称服务器必须在与权威名称服务器通话时再次重复整个过程，才能实际获取 food.com 的 IP。 这是 11 个数据包，总共运行 38 个数据包。 现在，本地名称服务器终于拥有了 food.com 的 IP 地址， 它最终可以响应初始请求。 对最初发出请求的 DNS 解析程序的响应， 然后此计算机发送一个 ACK 回来确认它收到了响应。 还有两个数据包 让我们在 40 岁 最后，需要通过四向握手关闭 TCP 连接。 这使我们至少 达到 44 个数据包，以便通过 TCP 执行完全递归的 DNS 请求。 就 现代网络的运行速度而言，44 个数据包并不是一个很大的数字。 但它加起来很快，你可以看到。 请记住，DNS 流量只是实际流量的前提。 计算机几乎总是执行 DNS 查找，因为它需 要知道域名的 IP 才能发送额外的数据， 而不仅仅是因为它很好奇。 现在，让我们看看 UDP 的外观。 扰流板警报，它不需要尽可能多的数据包。 原始计算机将 UDP 数据包发送到 端口 53 上的本地名称服务器，要求输入 food.com 的 IP，这是一个数据包。 本地名称服务器充当递归服务器，并向 根服务器发送 UDP 数据包，该数据包发送包含 正确 TLD 名称服务器的响应，即三个数据包。 递归名称服务器向 TLD 服务器发送数据包，并 接收包含正确授权服务器的响应。 我们现在有五个数据包。 接下来，递归名称服务器将其最终请求发送到 权威名称服务器，该名称服务器将发送包含 IP of food .com 的响应。 这是七个数据包 最后，本地名称服务器响应 DNS 解析器，首先使用 food .com 的 IP 发出请求。 这使得我们总共有八个数据包。 看，方式更少的数据包。 您现在可以看到 TCP 真正需要多少开销。 而对于像 DNS 这样简单的东西，它只是不需要。 这是为什么除了 更强大的 TCP 之外还存在 UDP 等协议的完美示例。 你可能想知道错误恢复如何发挥作用， 因为 UDP 没有任何。 答案非常简单。 DNS 解析器只是再次询问它是否没有得到响应。 基本上，应用程序层的 DNS 以最简单的方式提供了 TCP 在传输层提供的相同功能。 DNS 服务器永远不需要关心做任何事情，而是响应传入 的查找，DNS 解析程序只需执行查找并在不成功时重复查找。 DNS 和 UDP 的简单性的真实展示。 我应该指出，通过 TCP 的 DNS 实际上确实存在，并且在各地使用。 随 着 Web 变得越来越复杂，所有 DNS 查找响应都可以放入单个 UDP 数据报的情况已经不再是这种情况了。 在这些情况下，DNS 名称服务器将 使用数据包进行响应，说明响应过大。 然后 DNS 客户端将建立一个 TCP 连接以执行查找。