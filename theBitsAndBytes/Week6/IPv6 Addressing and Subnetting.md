## IPv6 Addressing and Subnetting

Time for some real talk. Here's the hard truth. The IANA is out of IP addresses. When IPv4 was first developed, a 32-bit number was chosen to represent the address for a node on a network. The Internet was in its infancy, and no one really expected it to explode in popularity the way it has. 32-bits were chosen, but it's just not enough space for the number of Internet connected devices we have in the world. IPv6 was developed exactly because of this issue. By the mid 1990s, it was more and more obvious that we were going to run out of IPv4 address space at some point, so a new Internet Protocol was developed. Internet Protocol version 6, or IPv6. You might wonder what happened to version 5, or IPv5. It's actually a fun bit of trivia. IPv5 was an experimental protocol that introduced the concept of connections. It never really saw wide adoption, and connection state was handled better later on by the transport layer and TCP. Even though IPv5 is mostly a relic of history, when development of IPv6 started, the consensus was to not reuse the IPv5 name. The biggest difference between IPv4 and IPv6 is the number of bits reserved for an address, while IPv4 addresses are 32 bits, meaning there can be around 4.2 billion individual addresses. IPv6 addresses are 128 bits in size. This size difference is staggering, once you do the math. Don't worry, we won't make you. 2 to the power of 128 would produce a 39 digit long number. That number range has a name you've probably never even heard of, an Undecillion. An Undecillion isn't a number you hear a lot, because it's ginormous. There really aren't things that exist at that scale. Some guesses on the total number of atoms that make up the entire planet Earth and every single thing on it get into that number range. That should tell you we're talking about a very, very large number. If we can give every atom on Earth its own IP address, we'll probably be okay when it comes to network devices for a very long time. Just for fun, let's look at what that number actually looks like. It looks like this. Whoa, mind blowing, right? Just like how an IPv4 address is really just a 32-bit binary number, IPv6 addresses are really just one 28-bit binary numbers. IPv4 addresses are written out in four octets of decimal numbers, just to make them a little more readable for humans. But trying to do the same for an IPv6 address just wouldn't work. Instead, IPv6 addresses are usually written out as 8 groups of 16-bits each. Each one of these groups is further made up of four hexadecimal numbers. A full IPv6 address might look something like this. That's still way too long, so IPv6 has a notation method that lets us break that down even more. A way to show how many IPv6 addresses there are is by looking at our example IP. Every single IPv6 address that begins with 2001:0db8 has been reserved for documentation, in education, or for books and courses, just like this one. That's over 18 quintillion addresses, much larger than the entire IPv4 address space reserved just for this purpose. There are two rules when it comes to shortening an IPv6 address. The first is that you can remove any leading zeros from a group. The second is that any number of consecutive groups composed of just zeros can be replaced with two colons. I should call out that this can only happen once for any specific address. Otherwise, you couldn't know exactly how many zeros were replaced by the double colons. For this IP, we could apply the first rule, and remove all leading zeros from each group. This would leave us with this. Once we apply the second rule, which is to replace consecutive sections containing just zeros with two colons, we'll end up with this. This still isn't as readable as an IPv4 address, but it's a good system that helps reduce the length a little bit. We can see this approach taken to the extreme with IPv6 loopback address. You might remember that with IPv4, this address is 127.0.0.1. With IPv6, the loopback address is 31 0s with a 1 at the end, which can be condensed all the way down to just ::1. The IPv6 address space has several other reserved address ranges, besides just the one reserved for documentation purposes, or the loopback address. For example, any address that begins with FF00:: is used for multicast, which is a way of addressing groups of hosts all at once. It's also good to know that addresses beginning with FE80:: are used for link-local unitcast. Link-local unicast addresses allow for local network segment communications, and are configured based upon a host's MAC address. The link-local address are used by an IPv6 hosts to receive their network configuration, which is a lot like how DHCP works. The host's MAC address is run through an algorithm to turn it from a 48-bit number into a unique 64-bit number. It's then inserted into the addresses host ID. The IPv6 address space is so huge, there was never any need to think about splitting it up into address classes like we used to do with IPv4. From the very beginning, an IPv6 address had a very simple line between network ID and host ID. The first 64-bits of any IPv6 address is the network ID, and the second 64-bits of any IPv6 address is the host ID. This means that any given IPv6 network has space for over 9 quintillion hosts. Still, sometimes network engineers might want to split up their network for administrative purposes. IPv6 subnetting uses the same CIDR notation that you're already familiar with. This is used to define a subnet mask against the network ID portion of an IPv6 address.



时间进行一些真正的谈话。 这是很难的事实。 IANA 的 IP 地址不足。 首次开发 IPv4 时， 选择了一个 32 位数字来表示网络中某个节点的地址。 互联网正处于起步阶段， 没有人真正希望它会像它的方式爆炸。 32 位被选择，但它只是没 有足够的空间来满足我们在世界上的互联网连接设备的数量。 IPv6 的开发正是因为这个问题。 到了 20 世纪 90 年代中期，越来越明显的是， 在某个时刻，IPv4 地址空间将耗尽，因此开发了一个新的互联网协议。 互联网协议版本 6 或 IPv6。 你可能想知道版本 5 或 IPv5 发生了什么。 这实际上是一个有趣的小琐事。 IPv5 是引入连接概念的实验性协议。 它从来没有真正看到广泛的采用，并且 连接状态稍后由传输层和 TCP 处理得更好。 尽管 IPv5 主要是历史遗迹，但在 IPv6 开发时，人们的共识是不重复使用 IPv5 名称。 IP@@ v4 和 IPv6 之间的最大区别是为 一个地址保留的位数，而 IPv4 地址为 32 位，这 意味着可能有大约 42 亿个单独的地址。 IPv6 地址的大小为 128 位。 这个大小的差异是惊人的，一旦你做了数学。 别担心，我们不会让你。2 设置为 128 的功率将产生一个 39 位数的长数字。 这个数字范围有一个你甚至从来没有听说过的名字， 一个 Undeillion。 一个不是你听到很多的数字，因为它是古怪的。 真的没有什么东西存在于这样的规模。 有 些猜测构成整个地球的原子总数和 它上的每一件事都进入这个数字范围。 这应该告诉你我们正在谈论一个非常，非常大的数字。 如果我们能够给地球上的每个原子自己的 IP 地址， 我们可能会很长一段时间的网络设备。 为了好玩，让我们来看看这个数字实际上是什么样子。 它看起来像这样。 哇，介意吹，对不对？ 就像 IPv4 地址实际上只是一个 32 位二进制数一样， IPv6 地址实际上只是一个 28 位二进制数字。 IPv4 地址以四个八进制数字编写， 只是为了使它们对人类更具可读性。 但试图为 IPv6 地址做同样的事情是行不通的。 相反，IPv6 地址通常被写成 8 组，每组 16 位。 这些组中的每一组还由四个十六进制数字组成。 完整的 IPv6 地址可能如下所示。这仍然太长了，所以 IPv6 有一个符号方法，可以让我们更详细地分解它。通过查看我们的示例 IP 来显示 IPv6 地址数量的一种方法。 从 2001：0 db8 开始的每个 IPv6 地址都被保留用于 文档、教育或书籍和课程，就像这样。 这超过 18 个五分之一的地址， 比为此目的保留的整个 IPv4 地址空间大得多。 缩短 IPv6 地址时，有两条规则。 首先，您可以从组中删除任何前导零。 第二个是，由 零组成的任意数量的连续组可以替换为两个冒号。 我应该呼吁，对于任何特定地址，这只能发生一次。 否则，您无法确切知道有多少个零被双 冒号替换。 对于这个 IP，我们可以应用第一个规则，并 从每个组中删除所有前导零。 这会给我们留下这个。一旦我们应用第二个规则，即用 两个冒号替换仅包含零的连续部分，我们将结束这个。 这仍然不像 IPv4 地址那样可读，但 它是一个很好的系统，有助于减少一点长度。 我们可以看到这种方法采用了 IPv6 环回地址。 您可能记得，使用 IPv4 时，此地址为 127.0.0.1。 使 用 IPv6 时，环回地址为 31 0，末尾 为 1，可以缩小到仅为። 1。 IPv6 地址空间还有其他几 个保留地址范围，除了仅为文档目的而保留的地址范围或环回地址。 例如，任何以 FF00። 开头的地址都用于 多播，这是一种同时寻址所有主机组的方式。 了解以 FE80። 开头的地址用于 链路本地单元转换也很好。 链路本地单播地址允许进行本地网段通信， 并根据主机的 MAC 地址进行配置。 IPv6 主机使用链路本地地址接收其 网络配置，这与 DHCP 的工作方式非常相似。 主机的 MAC 地址通过算法运行，将 其从 48 位数字转换为唯一的 64 位数字。 然后将其插入到地址主机 ID 中。 IPv6 地址空间如此巨大，从来没有必要 考虑像我们用 IPv4 做的那样将其拆分成地址类。 从一开始， IPv6 地址在网络 ID 和主机 ID 之间有一条非常简单的行。 任何 IPv6 地址的前 64 位是网络 ID， 任何 IPv6 地址的第二个 64 位是主机 ID。 这意味着任何给定的 IPv6 网络都可以容纳 9 个以上的五分之一的主机。 尽管如此，有时网络工程师可能会出于 管理目的而将其网络拆分出来。 IPv6 子网划分使用与您 已经熟悉的 CIDR 符号相同。 这用于针对 IPv6 地址的网络 ID 部分定义子网掩码。